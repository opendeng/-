<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nodejs的事件]]></title>
    <url>%2F2019%2F02%2F12%2Fnode%E7%9A%84%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Node.js EventEmitterEventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 你可以通过require(“events”);来访问该模块。 方法序号 方法 &amp; 描述 addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。 on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 server.on(‘connection’, function (stream) { console.log(‘someone connected!’); }); once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 server.once(‘connection’, function (stream) { console.log(‘Ah, we have our first user!’); }); removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 它接受两个参数，第一个是事件名称，第二个是回调函数名称。代码： 123456var callback = function(stream) &#123; console.log(&apos;someone connected!&apos;);&#125;;server.on(&apos;connection&apos;, callback);// ...server.removeListener(&apos;connection&apos;, callback); removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n) 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event) 返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])（发送事件，并执行监听器） 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。类方法序号 方法 &amp; 描述 listenerCount(emitter, event)返回指定事件的监听器数量。额，就是直接调用的。events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐events.emitter.listenerCount(eventName) //推荐事件序号 事件 &amp; 描述1 newListenerevent - 字符串，事件名称 listener - 处理事件函数 该事件在添加新监听器时被触发。 2 removeListenerevent - 字符串，事件名称 listener - 处理事件函数 从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引（会改变索引）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[在xamarin中的get管理包添加使用E…可以调用安卓的功能]]></title>
    <url>%2F2019%2F01%2F28%2FANzhuo%2F</url>
    <content type="text"><![CDATA[使用步骤：]]></content>
  </entry>
  <entry>
    <title><![CDATA[xamarin的 MessagingCenter]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[MessagingCenter。同一个字符串标识，但不同的泛型参数内容不会被发送到同一个侦听者（正常，即是说，参数类型也参与判断是否属于同一个侦听者）。一般配套使用接口：Subscribe (object subscriber, string message, Action callback, TSender source = null)//监听订阅&lt;尖括号代表侦听哪一个发送方&gt;（this是什么看接口，“字符串标识”，回调函数）Subscribe&lt;TSender, TArgs&gt; (object subscriber, string message, Action&lt;TSender, TArgs&gt; callback, TSender source = null)//监听订阅、、参数：若要使用消息传递参数，请在 Subscribe 泛型参数和操作签名中指定参数类型。TArgsSend (TSender sender, string message)Send&lt;TSender, TArgs&gt; (TSender sender, string message, TArgs args)Unsubscribe&lt;TSender, TArgs&gt; (object subscriber, string message)Unsubscribe (object subscriber, string message) MessagingCenter.Subscribe&lt;MainPage, string&gt; (this, “Hi”, (sender, arg) =&gt; {DisplayAlert(“Message Received”, “arg=” + arg, “OK”);});带参数 MessagingCenter.Unsubscribe&lt;MainPage, string&gt; (this, “Hi”);MessagingCenter.Send (this, “Hi”);//发送事件MessagingCenter.Send&lt;MainPage, string&gt; (this, “Hi”,”Json” ); MessagingCenter.Subscribe (this, “Hi”, (sender) =&gt; {Greetings.Add(“Hi”);//订阅，发送方主页面。订阅方操作。主页面的按钮操作});]]></content>
  </entry>
  <entry>
    <title><![CDATA[js原型]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[每个函数都有prototype属性；每个对象都有一个Proto属性，指向他的构造函数prototype属性。 每个对象都是由函数Fnnc()构造。所以函数的proto会指向Func() 对象与函数要分清。 对象是由函数构造的，但函数也是一个对象。一切都是函数，一切都是对象。 对象作为对象对象是一个Object对象，由function Object（）方法构造出来。所以构造函数的实例对象proto会指向构造函数的prototype。构造函数的prototype的proto会指向Object的prototype；object的prototypr的proto指向为null，为原型链的终点。（第一行说了。每个对象都有一个proto属性） 构造函数的prototype.的construtor指向构造函数。暂时理解构造的prototype有构造函数产生。（所有函数由Function函数构造）实例化一个构造函数是，实例的construtor（构造函数属性）默认使用构造函数的prototype的construtor属性（构造函数属性）。 Object对象也是由函数生成：对象的proto指向构造函数prototype；（）function函数由什么产生？原始函数的proto指向原始函数本身的prototype。 万物终焉为null，还是万物之始为null？指向本身代表什么……神明的不可描述。 等我再强一个阶段，再来详细解析。]]></content>
  </entry>
  <entry>
    <title><![CDATA[js作用域以及作用域链]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[函数的作用域在函数创建定义的时候就决定了，并不是由在哪里运行决定的。 当前的作用域中如果找不到变量，会从父作用域寻找变量定义，一直找下去，直到找到全局作用域，如果有就是有，没有就报错。这就是作用域链。 那么原型链呢。先说明，原型链与作用域链不是一样的东西。 原型关系到属性继承，作用域链，只是运行时变量的作用范围。 作用范围与继承还是有区别的。 突然发现吧原型链换成继承链真的好理解，不知道会不会理解错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2019%2F01%2F28%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包函数作为参数，或者返回值。 第一种情况：函数作为参数返回函数作为返回值，返会的函数使用了本函数的参数但定义返回函数的时候是确定了函数的作用域，返回函数使用了使用自由变量（本函数的变量，未在返回函数中定义的变量），所以要返回【返回函数】的那个函数的上下文对象不会被销毁； 返回函数奶住了函数执行环境的最后一口气，应该叫做闭包。 第二种情况：函数作为参数。函数作为参数，可以使用函数的父作用域的参数。？]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F25%2FActionT%E5%92%8CFuncT%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[相当于委托的简单写法。··C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托是保存对某个方法引用的一种引用类型变量。 使用Action&lt;T1，T2&gt;委托，则不需要显式定义委托，用于封装具有两个参数的方法。 若要引用的方法，具有两个参数并返回一个值，使用泛型Func&lt;T1，T2，TResult&gt;委托。 使用Action&lt;T1, T2&gt;委托，则不需要显式定义委托： 1using System;2using System.IO;3public class TestAction24｛5 public static void Main()6 ｛7 string message1 = “The first line of a message.”;8 string message2 = “The second line of a message.”;9 Action&lt;string, string&gt; concat;//这里用Action&lt;String，String&gt;定义了两个参数的委托。‘&lt;’这个是&lt;符号10 if (Environment.GetCommandLineArgs().Length &gt; 1)11 concat = WriteToFile;12 else13 concat = WriteToConsole;14 concat(message1, message2);15 ｝16 private static void WriteToConsole(string string1, string string2)17 ｛18 Console.WriteLine(“｛0｝\n｛1｝”, string1, string2);19 ｝20 private static void WriteToFile(string string1, string string2)21 ｛22 StreamWriter writer = null;23 try24 ｛25 writer = new StreamWriter(Environment.GetCommandLineArgs()[1], false);26 writer.WriteLine(“｛0｝\n｛1｝”, string1, string2);27 ｝28 catch29 ｛30 Console.WriteLine(“File write operation failed…”);31 ｝32 finally33 ｛34 if (writer != null) writer.Close();35 ｝36 ｝37｝38​ 二、使用delegate定义有返回值的委托： using System; delegate string[] ExtractMethod(string stringToManipulate, int maximum);//一般定义的委托会在delegate后面定义返回的类型。 public class DelegateExamp｛ public static void Main() ｛ ExtractMethod extractMeth = ExtractWords; string title = &quot;The Scarlet Letter&quot;; foreach (string word in extractMeth(title, 5)) Console.WriteLine(word); ｝ private static string[] ExtractWords(string phrase, int limit) ｛ char[] delimiters = new char[] ｛&apos; &apos;｝; if (limit &amp;gt; 0) return phrase.Split(delimiters, limit); else return phrase.Split(delimiters); ｝ ｝ ​ 使用泛型Func&lt;T1，T2，TResult&gt;委托， 则不需要显式定义委托： 1using System;2public class GenericFunc3｛4 public static void Main()5 ｛6 Func&lt;string, int, string[]&gt; extractMethod = ExtractWords;7 string title = “The Scarlet Letter”;8 foreach (string word in extractMethod(title, 5))9 Console.WriteLine(word);10 ｝11 private static string[] ExtractWords(string phrase, int limit)12 ｛13 char[] delimiters = new char[] ｛’ ‘｝;14 if (limit &gt; 0)15 return phrase.Split(delimiters, limit);16 else17 return phrase.Split(delimiters);18 ｝19｝20​ 总结：delegate string[] ExtractMethod(string stringToManipulate, int maximum);===Action&lt;类型的canshu,类型的canshu&gt;使用Action&lt;T1，T2&gt;委托和Func&lt;T1，T2，TResult&gt;委托，可以简化代码，让逻辑更清晰。 delegate string[] ExtractMethod(string stringToManipulate, int maximum);=== Func&lt;string, int, string[]&gt; extractMethod = ExtractWords;func&lt;&gt;委托的第三个参数式返回类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[接口]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口 接口有什么作用？ 定义抽象类的接口； 然后实现接口；（抽象类接口被继承的时候需要继承类实现所有的方法） 调用的时候，实例化实例化接口的类 然后使用接口不是多此一举？ 接口能直接反映类与类、对象之间的关系，一眼明了。 定义了接口，容易看懂实现类的功能。 便于管理 与C#命令模式的区别？？？？所以C#的命令模式与接口有什么区别？没区别待续…………]]></content>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[# 定义 命令模式的目的是解除命令发出者和接收者之间的紧密耦合关系，使二者相对独立，有利于程序的并行开发和代码的维护。 命令模式的核心思想是将请求封装为一个对象，将其作为命令发起者和接收者的中介，而抽象出来的命令对象又使得能够对一系列请求进行操作，如对请求进行排队，记录请求日志以及支持可撤销的操作等。 一个抽象类命令接口，只有Execute()执行方法–》然后这个抽象类被继承，继承这个抽象类实现执行方法，并且写下写具体命令 12关于元数据中的Command与ICommand：简单说，命令模式，就是只有一个拥有E...（）执行方法的抽象类，实例被绑定了具体的处理事件的内容，随时调用。解耦。 命令模式，只是模式。无关元数据的Commod类与ICommod主要组成： Command-命令父类或接口 ConcreteCommand-具体命令 Invoker-调用者 Receiver-接收者，（执行命令指定的相关操作） 理解流程大概是： 先定义一个接口，然后实现接口。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107相关类：using System; namespace Command&#123; /// &lt;summary&gt; /// 命令父类（或接口） /// &lt;/summary&gt; abstract class CommandClass（抽象类接口） &#123; public abstract void Execute(); &#125; ---------------------------------------------------------------------------------------- /// &lt;summary&gt; /// 打开文件（具体命令）（继承实现接口）（实现类） /// &lt;/summary&gt; class OpenFileCommand : CommandClass &#123; FileReceiver fileReceiver; public OpenFileCommand(FileReceiver fileReceiver) &#123; this.fileReceiver = fileReceiver; &#125; public override void Execute()//实现了这个方法 &#123; fileReceiver.OpenFile(); &#125; &#125;---------------------------------------------------------------------------------------------- /// &lt;summary&gt; /// 复制文件（具体命令）（继承实现接口）（实现类） /// &lt;/summary&gt; class CopyFileCommand : CommandClass &#123; FileReceiver fileReceiver;//一个属性 public CopyFileCommand(FileReceiver fileReceiver)//构造方法。 &#123; this.fileReceiver = fileReceiver;//这个指向到实例化对象手中 &#125; public override void Execute() &#123; fileReceiver.CopyFile();//执行方法 &#125; &#125; ------------------------------------------------------------------------------------------------ /// &lt;summary&gt; /// 文件（接收者，执行相关操作）（响应命令后所执行的操作。） /// &lt;/summary&gt; class FileReceiver &#123; public void OpenFile() &#123; Console.WriteLine(&quot;打开文件&quot;); &#125; public void CopyFile() &#123; Console.WriteLine(&quot;复制文件&quot;); &#125; &#125; ------------------------------------------------------------------------------------------- /// &lt;summary&gt; /// 调用者（可忽略调用者，直接调用Execute()命令） /// &lt;/summary&gt; class Invoker &#123; //调用命令 public void Invoke(CommandClass command)//（调用命令写成一个方法，需要参数传进抽象类） &#123; command.Execute(); &#125; &#125;&#125;-------------------------------------------------------------------调用：using System; namespace Command&#123; class Program &#123; static void Main(string[] args) &#123; //调用者 Invoker invoker = new Invoker(); //接收者 FileReceiver fileReceiver = new FileReceiver();（需要的操作，有两个输出方法） //具体命令（实现接口类的对象） OpenFileCommand openFileCommand = new OpenFileCommand(fileReceiver);//（实现类对象传入方法） //调用命令（需要一个命令类） invoker.Invoke(openFileCommand);（这个传入的类是继承的，所以也行）（传入的是已经实现的命令接口类） CopyFileCommand copyFileCommand = new CopyFileCommand(fileReceiver);//（实现类对象传入方法） invoker.Invoke(copyFileCommand); //直接调用； openFileCommand.Execute(); Console.Read(); &#125; &#125;&#125; 那么接口的作用是什么？ 事件被触发，与使用接口是不一样的。代码参考 命令模式。定义接口执行，实现接口。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#委托]]></title>
    <url>%2F2019%2F01%2F24%2FC%23%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[委托1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace Example_EventTest&#123;//这是事件绑定及触发使用委托。---------------------------------------------------------------------------------------无参数委托； class Judgment &#123; //定义一个委托 public delegate void delegateRun(); //定义一个事件 public event delegateRun eventRun; //引发事件的方法 public void Begin() &#123; 触发事件是加括号使用/？ eventRun();//被引发的事件 &#125; &#125;------------------------------------------------------------------------------------------单纯一个类，一个类里有一个方法。 class RunSports//这个类的方法委托上面的委托执行 &#123; //定义事件处理方法 public void Run() &#123; Console.WriteLine(&quot;运动员开始比赛&quot;); &#125; &#125;------------------------------------------------------------------------------------------- class Program &#123; static void Main(string[] args) &#123; RunSports runsport = new RunSports();//实例化事件发布者 Judgment judgment = new Judgment();//实例化事件订阅者 //订阅事件，给事件绑定委托，被委托的方法。 judgment.eventRun+=new Judgment.delegateRun(runsport.Run);//此处传进一个runsport.Run方法，委托Judgment实现|（也可以穿其他方法） //引发事件 judgment.Begin();//begin方法的eventRun事件触发，事件被委托到到delegateRun，这个委托方法实现runsport.Run。 Console.ReadKey();//按任意键继续………… &#125; &#125;&#125; 听说点击事件也算委托，可以对比一下理解？给点击时间绑定事件 另一种，给委托事件绑上事件using System;using System.IO;delegate void ConcatStrings(string string1, string string2);//带参数的委托public class TestDelegate｛ public static void Main() //主方法 ｛ string message1 = “The first line of a message.”;//一条信息 string message2 = “The second line of a message.”;//的字符串 ConcatStrings concat;//一个委托，方法对象。 if (Environment.GetCommandLineArgs().Length &gt; 1) concat = WriteToFile; else concat = WriteToConsole; concat(message1, message2); ｝ private static void WriteToConsole(string string1, string string2) ｛ Console.WriteLine(“｛0｝\n｛1｝”, string1, string2); ｝ private static void WriteToFile(string string1, string string2) ｛ StreamWriter writer = null; try ｛ writer = new StreamWriter(Environment.GetCommandLineArgs()[1], false); writer.WriteLine(“｛0｝\n｛1｝”, string1, string2); ｝ catch ｛ Console.WriteLine(“File write operation failed…”); ｝ finally ｛ if (writer != null) writer.Close(); ｝ ｝ ｝委托会把委托编译成类，所以调用相当于委托 变量= new 委托（参数）第二种·方法吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[xamarin上传图片]]></title>
    <url>%2F2019%2F01%2F23%2Fxamarin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[xamarin]]></title>
    <url>%2F2019%2F01%2F22%2Fxamarin%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[StackLayout叠堆布局上下/左右叠堆布局，具有属性：Orientation :布局方向，枚举类型，Vertical (垂直）/Horizontal（水平）,默认值:Vertical.Spacing :double类型，表示每个子视图之间的间隙, 默认值 6.0.VerticalOptions和HorizontalOptions：布局定位（既可以定位又可以设置布局元素大小），该属性的属性值有8个分别是:Start：在父布局开始位置Center：在父布局中间位置End：在父布局最后位置Fill：填充整个父布局的位置 StartAndExpand、CenterAndExpand、EndAndExpand、FillAndExpand，这种带AndExpand的作用就是：根据其他布局的内容大小，如果有空白位置就会自动填充。当多个属性值都是AndExpand则会平分空白部分。 直接设置高度宽度可以用HeightRequest和WidthRequest； VerticalOptions和HorizontalOptions与WidthRequest和HeightRequest的优先级关系是什么？ 我们发现 Options和Request 的属性值所定义的大小谁大就以谁的值为主。 在垂直方向（水平方向）设置宽度WidthRequest（高度HeightRequest）无效 绝对布局：absolutelayoutAbsoluteLayout布局的子视图，通过AbsoluteLayout.LayoutBounds属性来位置和大小，AbsoluteLayout.LayoutFlags属性指定是绝对值还是比例值。LayoutBounds是Rectangle类型对象，拥有如下四个值，AbsoluteLayouty也是通过这四个值确定子视图的位置和大小。{X – 子视图的水平坐标Y – 子视图的垂直坐标Width – 子视图的宽度Height – 子视图的高度}相对值设置需指定0～1之间的一个double值，表示子视图与布局之间的对应关系，如：子视图的Width为一个.5的相对值，定义在一个宽度为480的Layout中，则子视图的宽度为480 ＊ 0.5 ＝ 240.绝对值使用明确值设置子视图的X，Y，Width，Heigh值即可. LayoutFlags是AbsoluteLayoutFlags类型枚举,多个枚举值可以通过逗号分隔（XAML中）组合使用。{None – 默认值。表示X，Y，Width，Height四个值都是绝对值.All – 表示所有值都是相对值.WidthProportional – 只有Width是相对值.HeightProportional – 只有Height是相对值.XProportional – 只有X是相对值.YProportional – 只有Y是相对值.PositionProportional – X,Y 是相对值.SizeProportional – Width和Height是相对值.}本文示例Xaml定义如下：123456&lt;AbsoluteLayout&gt; &lt;Label Text=&quot;Left Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;0,.5,20,200&quot; //指定位置AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt;//指定参数是比例还是绝对值 &lt;Label Text=&quot;Top Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;.5,0,200,20&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt; &lt;Label Text=&quot;Rop Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;1,.5,20,200&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt; &lt;Label Text=&quot;Right Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;.5,1,200,20&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt;&lt;/AbsoluteLayout&gt; 代码中定义布局子视图调用AbsoluteLayout提供的静态方法：AbsoluteLayout.SetLayoutBounds设置AbsoluteLayout.LayoutBounds属性，AbsoluteLayout.SetLayoutFlags设置AbsoluteLayout.LayoutFlags属性。 # 相对布局：relativeLayout 了解约束：约束（在一个视图内定位和调整大小RelativeLayout是用约束来完成的。约束表达式可以包括以下信息： 键入 - 约束是否相对于父或另一个视图。属性 - 用作约束的依据的属性。因子 - 适用于物业价值的因素。Constant - 用作值偏移量的值。ElementName - 约束相对于的视图的名称。） xaml例子：1234567891011&lt;BoxView Color=&quot;Green&quot; WidthRequest=&quot;50&quot; HeightRequest=&quot;50&quot; RelativeLayout.XConstraint = &quot;&#123;ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.5, Constant=-100&#125;&quot; RelativeLayout.YConstraint = &quot;&#123;ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.5, Constant=-100&#125;&quot; /&gt; 网格布局：Grid目的 –的常见用途Grid。使用情况 –如何使用Grid来实现您所需的设计。行和列 –指定行和列Grid。将视图放置 –将视图添加到在网格中的特定行和列。间距 –配置行和列之间的空格。Span –配置跨越多个行或列的元素。 用法：与传统表不同Grid无法推断的数量和大小的行和列的内容。 相反，Grid已RowDefinitions和ColumnDefinitions集合。 这些日志包含行数和列布局方式的定义。视图将添加到Grid使用指定的行和列索引，该标识所属的行和列应置于一个视图。1234567891011121314&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot; /&gt; &lt;RowDefinition Height=&quot;*&quot; /&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;*&quot; /&gt; &lt;ColumnDefinition Width=&quot;*&quot; /&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Label Text=&quot;Top Left&quot; Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; /&gt; &lt;Label Text=&quot;Top Right&quot; Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; /&gt; &lt;Label Text=&quot;Bottom Left&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; /&gt; &lt;Label Text=&quot;Bottom Right&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; /&gt;&lt;/Grid&gt; FlexLayout属性：Direction 属性设置为值为 FlexDirection 枚举。 默认值为 Row。 将属性设置为Column导致的子级FlexLayout排列在项的单个列中。当中的项FlexLayout排列在列中，FlexLayout称其具有垂直_主轴和水平交叉轴_。AlignItems 属性属于类型 FlexAlignItems 和指定的项在横轴上的对齐方式。 Center选项将使每一项要在水平居中。 ps： 与此更改后，这个Label定位在的左边缘FlexLayout时的阅读顺序是从左到右。 ScrollView 定义以下属性：ContentSize 获取 Size 值，该值表示内容的大小。Orientation 获取或设置 ScrollOrientation 枚举值，该值表示滚动的方向ScrollView。ScrollX 获取double，它表示当前的滚动位置。ScrollY 获取double，表示当前 Y 滚动位置。HorizontalScrollBarVisibility 获取或设置 ScrollBarVisibility 值，该值表示当水平滚动条是否可见。VerticalScrollBarVisibility 获取或设置 ScrollBarVisibility 值，该值表示当垂直滚动条是否可见。]]></content>
  </entry>
  <entry>
    <title><![CDATA[怎么安装使用搜索功能]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[好像并没有成功npm install hexo-generator-searchdb –save 修改 站点配置 文件 search: path: search.xml field: post format: html limit: 10000 修改 主题配置文件 local_search: enable: true？？？？]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F21%2F%E5%8A%A0%E8%97%A4%2F</url>
    <content type="text"><![CDATA[安装制片人安装npm包： npm install –save hexo-helper-live2d 然后在hexo的配置文件_config.yml中添加如下配置，详细配置可以参考文档： live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 下载模型 npm install live2d-widget-model-shizuku 所有模型：live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install –save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install –save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 下载完之后，在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后编辑配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# CallerMemberName、CallerFilePath和CallerLineNumber特性]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%89%B9%E6%80%A7CallerMemberName%E3%80%81CallerFilePath%E5%92%8CCallerLineNumber%2F</url>
    <content type="text"><![CDATA[这三个特性是，获取属性（成员名称）、文件路径、第几行号：例子：12345678910111213141516171819202122 /// &lt;summary&gt; /// Writes the error. /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;The message to be written.&lt;/param&gt; public void WriteError(object message) &#123; _log4Net.Error(message); &#125;复制代码如果想区分调用来源就比较麻烦了。在.Net 4.5中引入了三个Attribute：CallerMemberName、CallerFilePath和CallerLineNumber 。在编译器的配合下，分别可以获取到调用函数（准确讲应该是成员）名称，调用文件及调用行号。这时可以把方法改成： /// &lt;summary&gt; /// Writes an error level logging message. /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;The message to be written.&lt;/param&gt; public void WriteError(object message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string sourceFilePath = &quot;&quot;, [CallerLineNumber] int sourceLineNumber = 0) &#123; _log4Net.ErrorFormat(&quot;文件:&#123;0&#125; 行号:&#123;1&#125; 方法名:&#123;2&#125;,消息:&#123;3&#125;&quot;, sourceFilePath, sourceLineNumber, memberName, message); &#125; 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVVM模式]]></title>
    <url>%2F2019%2F01%2F21%2FMVVm%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Model- ViewModel-View Model:主要是定义属性；ViewModel：视图数据响应，一般需要继承INotifyPropertyChanged。 主要是数据的逻辑处理。View：引用viewmodel并从ViewModel获取数据并显示数据。 INotifyPropertyChanged //实现数据变动接口 #region INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged;//事件委托 protected void OnPropertyChanged([CallerMemberName] string propertyName = &quot;&quot;) { var changed = PropertyChanged; if (changed == null) return; changed.Invoke(this, new PropertyChangedEventArgs(propertyName)); } #endregion]]></content>
  </entry>
  <entry>
    <title><![CDATA[xamarin动画]]></title>
    <url>%2F2019%2F01%2F21%2Fxamarin%2F</url>
    <content type="text"><![CDATA[xamarin缓慢函数，直接：Easing调用，作为动画的参数使用Easing 类定义了大量可供动画的缓动函数：BounceIn 缓动函数弹跳动画的开头。BounceOut 缓动函数弹跳动画结束时。CubicIn 缓动函数缓慢加速动画。CubicInOut 缓动函数在开始时，动画加速和减速的动画结束时。CubicOut 快速缓动函数减速的动画。Linear 缓动函数使用常量的速度，并且默认的缓动函数。SinIn 顺利缓动函数加速动画。SinInOut 顺利缓动函数加快在开始时，动画并平稳减速的动画结束时。SinOut 顺利缓动函数减速的动画。SpringIn 缓动函数使动画结束时非常快速地加快速度。SpringOut 缓动函数使动画结束时快速减速。In和Out后缀指示缓动函数提供的效果是明显的动画，和 / 或结束时，在开头。12345await image.TranslateTo(0, 200, 2000, Easing.BounceIn);await image.ScaleTo(2, 2000, Easing.CubicIn);await image.RotateTo(360, 2000, Easing.SinInOut);await image.ScaleTo(1, 2000, Easing.CubicOut);await image.TranslateTo(0, -200, 2000, Easing.BounceOut); 关于xaml定义name属性，有时需要重新生成解决方案自定义动画，没看]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2019%2F01%2F18%2FVue%2F</url>
    <content type="text"><![CDATA[计算属性模块：{计算属性：function（）{}//geter，一般只有这个。 } 计算属性模块：{计算属性：{getter：function（）{}，setter：function（）{}//默认只有getter，可以添加} } var vm = new Vue({ el: ‘#demo’, data: { firstName: ‘Foo’, lastName: ‘Bar’, fullName: ‘Foo Bar’ }, watch: {//侦听器 firstName: function (val) { this.fullName = val + ‘ ‘ + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ‘ ‘ + val } }}) computed: { now: function () { return Date.now() }}这种是返回方法会消耗等很久，返回属性会有缓存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js stream]]></title>
    <url>%2F2019%2F01%2F18%2Fnodejs%20stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[(看到这里终于知道http的request为什么能定义监听器了)Node.js Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 本教程会为大家介绍常用的流操作。读取12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var data = &apos;菜鸟教程官网地址：www.runoob.com&apos;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 使用 utf8 编码写入数据writerStream.write(data,&apos;UTF8&apos;);// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;);writerStream.on(&apos;error&apos;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 写入12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var data = &apos;菜鸟教程官网地址：www.runoob.com&apos;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 使用 utf8 编码写入数据writerStream.write(data,&apos;UTF8&apos;);// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;);writerStream.on(&apos;error&apos;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 管道流12345678910111213var fs = require(&quot;fs&quot;);// 创建一个可读流var readerStream = fs.createReadStream(&apos;input.txt&apos;);// 创建一个可写流var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(&quot;程序执行完毕&quot;); 链接流123456789101112131415161718192021222324252627282930313233链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建 compress.js 文件, 代码如下：var fs = require(&quot;fs&quot;);var zlib = require(&apos;zlib&apos;);// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream(&apos;input.txt&apos;) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;)); console.log(&quot;文件压缩完成。&quot;);代码执行结果如下：$ node compress.js 文件压缩完成。执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：var fs = require(&quot;fs&quot;);var zlib = require(&apos;zlib&apos;);// 解压 input.txt.gz 文件为 input.txtfs.createReadStream(&apos;input.txt.gz&apos;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(&apos;input.txt&apos;)); console.log(&quot;文件解压完成。&quot;); 总所周知，链接流就是一路点下去………………..链式编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js 的util工具]]></title>
    <url>%2F2019%2F01%2F18%2FnodejsUtil%2F</url>
    <content type="text"><![CDATA[很有用util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 1234567891011121314151617181920212223var util = require(&apos;util&apos;); //、、导入的模块的写法：导入工具类 function Base() &#123; //构造函数：属性&amp;方法&amp;控制台的一句话 this.name = &apos;base&apos;; this.base = 1991; this.sayHello = function() &#123; console.log(&apos;Hello &apos; + this.name); &#125;; &#125; Base.prototype.showName = function() &#123; //往原型里面加入showName方法。 console.log(this.name);&#125;; function Sub() &#123; //构造方法 this.name = &apos;sub&apos;; &#125; util.inherits(Sub, Base); //这种原型继承不会难到被继承对象本来的属性和方法，只能拿到原型的var objBase = new Base();//创建对象 objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.showName(); //在base的原型里面//objSub.sayHello(); console.log(objSub); 所以inherits(要继承，被继承)只是继承了原型。 ddd this在原型里也指向他的对象 1/18/2019 1:56:30 PM util.inspectutil.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。 特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。12345678910111213141516171819202122var util = require(&apos;util&apos;); function Person() &#123; this.name = &apos;byvoid&apos;; this.toString = function() &#123; return this.name; &#125;; &#125; var obj = new Person(); console.log(util.inspect(obj)); console.log(util.inspect(obj, true)); 运行结果是：Person &#123; name: &apos;byvoid&apos;, toString: [Function] &#125;Person &#123; name: &apos;byvoid&apos;, toString: &#123; [Function] [length]: 0, [name]: &apos;&apos;, [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArray(object)如果给定的参数 “object” 是一个数组返回true，否则返回false。12345678910var util = require(&apos;util&apos;);util.isArray([]) // trueutil.isArray(new Array) // trueutil.isArray(&#123;&#125;) // false 1234567891011util.isRegExp(object)如果给定的参数 &quot;object&quot; 是一个正则表达式返回true，否则返回false。var util = require(&apos;util&apos;);util.isRegExp(/some regexp/) // trueutil.isRegExp(new RegExp(&apos;another regexp&apos;)) // trueutil.isRegExp(&#123;&#125;) // false 12345678910111213141516171819202122util.isDate(object)如果给定的参数 &quot;object&quot; 是一个日期返回true，否则返回false。var util = require(&apos;util&apos;);util.isDate(new Date()) // trueutil.isDate(Date()) // false (without &apos;new&apos; returns a String)util.isDate(&#123;&#125;) // falseutil.isError(object)如果给定的参数 &quot;object&quot; 是一个错误对象返回true，否则返回false。var util = require(&apos;util&apos;);util.isError(new Error()) // trueutil.isError(new TypeError()) // trueutil.isError(&#123; name: &apos;Error&apos;, message: &apos;an error occurred&apos; &#125;) // false 没兴趣了，全世界都在放假……]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs的http模块]]></title>
    <url>%2F2019%2F01%2F18%2Fnodejshttp%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[华丽的分割线 先复制一段代码:搭建服务器12345678910111213141516171819202122232425http模块主要用于搭建HTTP服务。使用Node搭建HTTP服务器非常简单。var http = require(&apos;http&apos;);http.createServer(function (request, response)&#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;).listen(8080, &apos;127.0.0.1&apos;);console.log(&apos;Server running on port 8080.&apos;);// 另一种写法function onRequest(request, response) &#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;http.createServer(onRequest).listen(process.env.PORT);上面代码第一行var http = require(&quot;http&quot;)，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例。**ceateServer方法接受一个函数作为参数（这个函数有两个参数，一个请求，一个响应），该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法用来写入HTTP回应的头信息；response.end方法用来写入HTTP回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。**将上面这几行代码保存成文件app.js，然后执行该脚本，服务器就开始运行了。 创建一个服务器实例需要一个回调函数。这个回调函数第一个参数是一个request对象，拥有属性 &gt;url :发初请求的网址 &gt;method ：HTtp请求的方法 &gt;headers： Http请求的的所有Http头信息 &gt;url 1var pathname = url.parse(request.url).pathname; 1234567891011121314151617setEncoding()方法用于设置请求的编码。request.setEncoding(&quot;utf8&quot;);addListener()方法用于为请求添加监听事件的回调函数。var querystring = require(&apos;querystring&apos;);var postData = &apos;&apos;;request.addListener(&apos;data&apos;, function (postDataChunk) &#123; postData += postDataChunk;&#125;);request.addListener(&apos;end&apos;, function () &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&quot;You&apos;ve sent the text: &quot; + querystring.parse(postData).text); response.end();&#125;); http状态码 http的基本用法： 处理get请求处理post请求处理异步操作request对象 发出请求 get()post() server() 算了，下面写 http.STATUS_CODES是一个对象，属性名都是状态码，属性值则是该状态码的简短解释。12require(&apos;http&apos;).STATUS_CODES[&apos;301&apos;]// &quot;Moved Permanently&quot; 模块属性模块属性（1）HTTP请求的属性 &gt; headers：HTTP请求的头信息。 &gt; url：请求的路径。 模块方法（1）http模块的方法 &gt; createServer(callback)：创造服务器实例。（2）服务器实例的方法 &gt; listen(port)：启动服务器监听指定端口。123456789101112131415listen方法用于启动服务器，它可以接受多种参数。var server = new http.Server();// 端口server.listen(8000);// 端口，主机server.listen(8000, &apos;localhost&apos;);// 对象server.listen(&#123; port: 8000, host: &apos;localhost&apos;,&#125;) （3）HTTP回应的方法 &gt; setHeader(key, value)：指定HTTP头信息。 &gt; write(str)：指定HTTP回应的内容。 &gt; end()：发送HTTP回应。 http服务器中：req.end()必须被调用，即使没有在请求体内写入任何数据，也必须调用。因为这表示已经完成HTTP请求。 发送过程的任何错误（DNS错误、TCP错误、HTTP解析错误），都会在request对象上触发error事件。 不想写了： 参考：链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[1月18日 http协议]]></title>
    <url>%2F2019%2F01%2F18%2Fhttp%2F</url>
    <content type="text"><![CDATA[http协议浏览器按F12查看network给出信息与http报文不太一样，虽说能找到一样请求地址之类的东西，但是有点get不到点上脑子痛，或者说是浏览器的整理功能？ 无语 【http请求】的特点：无状态。每次请求都是新的，这次的请求与上一次的请求没有联系。所以，一般用cookie和session强行联系，即是http携带Cookie或session的数据。 http报文由三部分组成:开始行（请求行）、首部行和实体主体三个部分之间要换行，首部行与实体隔开一个空行开始行（请求行）： 方法 url 版本 （之间有空格）首部行： 字段：值 主体； 例子1234567891011GET /wxisme HTTP/1.1 （请求行）Host: www.cnblogs.com （首部行）User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; zh-CN; rv:1.8.1) Gecko/20061010 Firefox/2.0 Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5 Accept-Language: en-us,zh-cn;q=0.7,zh;q=0.3 Accept-Encoding: gzip,deflate Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Proxy-Connection: keep-alive Cookie: ASP.NET_SessionId=ey5drq45lsomio55hoydzc45Cache-Control: max-age=0 响应报文（格式和请求报文一样）：开始行：版本 状态码 短语首部行：字段：值 实体主体； 12345678910HTTP/1.1 200 OKDate: Tue, 12 Jul 2016 21:36:12 GMTContent-Length: 563Content-Type: text/html&lt;html&gt; &lt;body&gt; Hello http! &lt;/body&gt;&lt;/html&gt; 复制粘贴：四、HTTP请求方法 请求方法是客户端用来告知服务器其动作意图的方法。就像下达命令一样。在HTTP1.1版本中支持GET、POST等近10种方法。需要注意的是方法名区分大小写，需要用大写字母。下面详细说明。 1.GET：获取资源 GET方法用来请求访问已被URI识别的资源。也就是指定了服务器处理请求之后响应的内容。 2.POST：传输实体主体 POST方法用来传输实体主体。POST与GET的区别之一就是目的不同，二者之间的区别会在文章的最后详细说明。虽然GET方法也可以传输，但是一般不用，因为GET的目的是获取，POST的目的是传输。 3.PUT：传输文件 PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。 4.HEAD：获得报文首部 HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。用于确认URI的有效性及资源更新时间等。 5.DELETE：删除文件 DELETE方法用来删除文件，是与PUT相反的方法。DELETE是要求返回URL指定的资源。 6.OPTIONS：询问支持的方法 因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法例如DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。 7.TRACE：追踪路径 TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。这个方法并不常用。 8.CONNECT：要求用隧道协议连接代理 CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL/TLS协议对通信内容加密后传输。 get与post请求：get携带参数会携带在url？或者&amp;符号后面，容易被获取信息，并且url长度有限制，所以get请求方式会有大小限制；post请求会把参数加密； session与cookie &gt;Coolie保存在客户端 &gt;session保存在服务器 &gt;session基于Cookie之上操作（session返回的sessionid会被保留在Cookie里面）。 &gt;session给了Cookie一条钥匙，让服务器辨认（如过sessionID相同，就是同一个回话。。。。应对解决http的无状态特点）。 首部行&amp;以上参考：https://www.cnblogs.com/wxisme/p/6212797.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[一篇糟糕的md文件写成html]]></title>
    <url>%2F2019%2F01%2F17%2Fyou%2F</url>
    <content type="text"><![CDATA[糟糕的标题3打两个空格表示换行请务必记得标签后记得空一空格一切都是两个空格，这是错的但会变色（手动狗头）有序列表以第一个数字为准标记符号记得要空一行，不然 这 是 表 格 真 的 无 语 不 知 数 据 怎 么 获 取 傻逼 引用好用吗好用啊我叫区块引用呵呵 引用包涵体超级引用 你好 世界 无序列表*、+、—都可以创建 有序，与上面隔开 我是第一 我是第二 我是第三 我是第四 # 华丽的分割线table就有两条 分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 4399是什么网站4399是什么网站参数式用法跟链接canshu的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的图片可以像连接一样参数式放进任何地方参数类似于html的title，需要双引号注释什么都会显示出来的代码框，装代码的，不会被使用12345这是注释多行的代码框&lt;p&gt;&lt;/p&gt; 1 2 1 2 转义是反斜杠 _倾斜_加粗 head head head center left right center left right center left right]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F17%2FNew%20Document%2F</url>
    <content type="text"><![CDATA[title: wuliao你好啊啊啊这就是用系统自带的方法写成的文章……虽然只有一点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你好啊]]></title>
    <url>%2F2019%2F01%2F17%2F%E4%BD%A0%E5%A5%BD%E5%95%8A%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hexo博客自带的编写新文章的教程。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
