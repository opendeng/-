<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[怎么安装使用搜索功能]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[npm install hexo-generator-searchdb –save 修改 站点配置 文件 search: path: search.xml field: post format: html limit: 10000 修改 主题配置文件 local_search: enable: true？？？？]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F21%2F%E5%8A%A0%E8%97%A4%2F</url>
    <content type="text"><![CDATA[安装制片人安装npm包： npm install –save hexo-helper-live2d 然后在hexo的配置文件_config.yml中添加如下配置，详细配置可以参考文档： live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 下载模型 npm install live2d-widget-model-shizuku 所有模型：live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install –save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install –save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 下载完之后，在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后编辑配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# CallerMemberName、CallerFilePath和CallerLineNumber特性]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%89%B9%E6%80%A7CallerMemberName%E3%80%81CallerFilePath%E5%92%8CCallerLineNumber%2F</url>
    <content type="text"><![CDATA[这三个特性是，获取属性（成员名称）、文件路径、第几行号：例子：12345678910111213141516171819202122 /// &lt;summary&gt; /// Writes the error. /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;The message to be written.&lt;/param&gt; public void WriteError(object message) &#123; _log4Net.Error(message); &#125;复制代码如果想区分调用来源就比较麻烦了。在.Net 4.5中引入了三个Attribute：CallerMemberName、CallerFilePath和CallerLineNumber 。在编译器的配合下，分别可以获取到调用函数（准确讲应该是成员）名称，调用文件及调用行号。这时可以把方法改成： /// &lt;summary&gt; /// Writes an error level logging message. /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;The message to be written.&lt;/param&gt; public void WriteError(object message, [CallerMemberName] string memberName = &quot;&quot;, [CallerFilePath] string sourceFilePath = &quot;&quot;, [CallerLineNumber] int sourceLineNumber = 0) &#123; _log4Net.ErrorFormat(&quot;文件:&#123;0&#125; 行号:&#123;1&#125; 方法名:&#123;2&#125;,消息:&#123;3&#125;&quot;, sourceFilePath, sourceLineNumber, memberName, message); &#125; 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVVM模式]]></title>
    <url>%2F2019%2F01%2F21%2FMVVm%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Model- ViewModel-View Model:主要是定义属性；ViewModel：视图数据响应，一般需要继承INotifyPropertyChanged。主要是数据的处理。View：从ViewModel获取数据并显示数据。 INotifyPropertyChanged //实现数据变动接口 #region INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged;//事件委托 protected void OnPropertyChanged([CallerMemberName] string propertyName = &quot;&quot;) { var changed = PropertyChanged; if (changed == null) return; changed.Invoke(this, new PropertyChangedEventArgs(propertyName)); } #endregion]]></content>
  </entry>
  <entry>
    <title><![CDATA[xamarin]]></title>
    <url>%2F2019%2F01%2F21%2Fxamarin%2F</url>
    <content type="text"><![CDATA[xamarin缓慢函数，直接：Easing调用，作为动画的参数使用Easing 类定义了大量可供动画的缓动函数：BounceIn 缓动函数弹跳动画的开头。BounceOut 缓动函数弹跳动画结束时。CubicIn 缓动函数缓慢加速动画。CubicInOut 缓动函数在开始时，动画加速和减速的动画结束时。CubicOut 快速缓动函数减速的动画。Linear 缓动函数使用常量的速度，并且默认的缓动函数。SinIn 顺利缓动函数加速动画。SinInOut 顺利缓动函数加快在开始时，动画并平稳减速的动画结束时。SinOut 顺利缓动函数减速的动画。SpringIn 缓动函数使动画结束时非常快速地加快速度。SpringOut 缓动函数使动画结束时快速减速。In和Out后缀指示缓动函数提供的效果是明显的动画，和 / 或结束时，在开头。12345await image.TranslateTo(0, 200, 2000, Easing.BounceIn);await image.ScaleTo(2, 2000, Easing.CubicIn);await image.RotateTo(360, 2000, Easing.SinInOut);await image.ScaleTo(1, 2000, Easing.CubicOut);await image.TranslateTo(0, -200, 2000, Easing.BounceOut); 关于xaml定义name属性，有时需要重新生成解决方案自定义动画，没看]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2019%2F01%2F18%2FVue%2F</url>
    <content type="text"><![CDATA[计算属性模块：{计算属性：function（）{}//geter，一般只有这个。 } 计算属性模块：{计算属性：{getter：function（）{}，setter：function（）{}//默认只有getter，可以添加} } var vm = new Vue({ el: ‘#demo’, data: { firstName: ‘Foo’, lastName: ‘Bar’, fullName: ‘Foo Bar’ }, watch: {//侦听器 firstName: function (val) { this.fullName = val + ‘ ‘ + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ‘ ‘ + val } }}) computed: { now: function () { return Date.now() }}这种是返回方法会消耗等很久，返回属性会有缓存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js stream]]></title>
    <url>%2F2019%2F01%2F18%2Fnodejs%20stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[(看到这里终于知道http的request为什么能定义监听器了)Node.js Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 本教程会为大家介绍常用的流操作。读取12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var data = &apos;菜鸟教程官网地址：www.runoob.com&apos;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 使用 utf8 编码写入数据writerStream.write(data,&apos;UTF8&apos;);// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;);writerStream.on(&apos;error&apos;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 写入12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var data = &apos;菜鸟教程官网地址：www.runoob.com&apos;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 使用 utf8 编码写入数据writerStream.write(data,&apos;UTF8&apos;);// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;);writerStream.on(&apos;error&apos;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 管道流12345678910111213var fs = require(&quot;fs&quot;);// 创建一个可读流var readerStream = fs.createReadStream(&apos;input.txt&apos;);// 创建一个可写流var writerStream = fs.createWriteStream(&apos;output.txt&apos;);// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(&quot;程序执行完毕&quot;); 链接流123456789101112131415161718192021222324252627282930313233链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建 compress.js 文件, 代码如下：var fs = require(&quot;fs&quot;);var zlib = require(&apos;zlib&apos;);// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream(&apos;input.txt&apos;) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;)); console.log(&quot;文件压缩完成。&quot;);代码执行结果如下：$ node compress.js 文件压缩完成。执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：var fs = require(&quot;fs&quot;);var zlib = require(&apos;zlib&apos;);// 解压 input.txt.gz 文件为 input.txtfs.createReadStream(&apos;input.txt.gz&apos;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(&apos;input.txt&apos;)); console.log(&quot;文件解压完成。&quot;); 总所周知，链接流就是一路点下去………………..链式编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js 的util工具]]></title>
    <url>%2F2019%2F01%2F18%2FnodejsUtil%2F</url>
    <content type="text"><![CDATA[很有用util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 1234567891011121314151617181920212223var util = require(&apos;util&apos;); //导入工具类 function Base() &#123; //构造函数：属性&amp;方法&amp;控制台的一句话 this.name = &apos;base&apos;; this.base = 1991; this.sayHello = function() &#123; console.log(&apos;Hello &apos; + this.name); &#125;; &#125; Base.prototype.showName = function() &#123; //往原型里面加入showName方法。 console.log(this.name);&#125;; function Sub() &#123; //构造方法 this.name = &apos;sub&apos;; &#125; util.inherits(Sub, Base); //这种原型继承不会难到被继承对象本来的属性和方法，只能拿到原型的var objBase = new Base();//创建对象 objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.showName(); //在base的原型里面//objSub.sayHello(); console.log(objSub); 所以inherits(要继承，被继承)只是继承了原型。 ddd this在原型里也指向他的对象 1/18/2019 1:56:30 PM util.inspectutil.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。 特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。12345678910111213141516171819202122var util = require(&apos;util&apos;); function Person() &#123; this.name = &apos;byvoid&apos;; this.toString = function() &#123; return this.name; &#125;; &#125; var obj = new Person(); console.log(util.inspect(obj)); console.log(util.inspect(obj, true)); 运行结果是：Person &#123; name: &apos;byvoid&apos;, toString: [Function] &#125;Person &#123; name: &apos;byvoid&apos;, toString: &#123; [Function] [length]: 0, [name]: &apos;&apos;, [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArray(object)如果给定的参数 “object” 是一个数组返回true，否则返回false。12345678910var util = require(&apos;util&apos;);util.isArray([]) // trueutil.isArray(new Array) // trueutil.isArray(&#123;&#125;) // false 1234567891011util.isRegExp(object)如果给定的参数 &quot;object&quot; 是一个正则表达式返回true，否则返回false。var util = require(&apos;util&apos;);util.isRegExp(/some regexp/) // trueutil.isRegExp(new RegExp(&apos;another regexp&apos;)) // trueutil.isRegExp(&#123;&#125;) // false 12345678910111213141516171819202122util.isDate(object)如果给定的参数 &quot;object&quot; 是一个日期返回true，否则返回false。var util = require(&apos;util&apos;);util.isDate(new Date()) // trueutil.isDate(Date()) // false (without &apos;new&apos; returns a String)util.isDate(&#123;&#125;) // falseutil.isError(object)如果给定的参数 &quot;object&quot; 是一个错误对象返回true，否则返回false。var util = require(&apos;util&apos;);util.isError(new Error()) // trueutil.isError(new TypeError()) // trueutil.isError(&#123; name: &apos;Error&apos;, message: &apos;an error occurred&apos; &#125;) // false 没兴趣了，全世界都在放假……]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodejs的http模块]]></title>
    <url>%2F2019%2F01%2F18%2Fnodejshttp%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[华丽的分割线 先复制一段代码:搭建服务器12345678910111213141516171819202122232425http模块主要用于搭建HTTP服务。使用Node搭建HTTP服务器非常简单。var http = require(&apos;http&apos;);http.createServer(function (request, response)&#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;).listen(8080, &apos;127.0.0.1&apos;);console.log(&apos;Server running on port 8080.&apos;);// 另一种写法function onRequest(request, response) &#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;http.createServer(onRequest).listen(process.env.PORT);上面代码第一行var http = require(&quot;http&quot;)，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例。ceateServer方法接受一个函数作为参数，该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法用来写入HTTP回应的头信息；response.end方法用来写入HTTP回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。将上面这几行代码保存成文件app.js，然后执行该脚本，服务器就开始运行了。 创建一个服务器实例需要一个回调函数。这个回调函数第一个参数式一个request对象，拥有属性 &gt;url :发初请求的网址 &gt;method ：HTtp请求的方法 &gt;headers： Http请求的的所有Http头信息 &gt;url 1var pathname = url.parse(request.url).pathname; 1234567891011121314151617setEncoding()方法用于设置请求的编码。request.setEncoding(&quot;utf8&quot;);addListener()方法用于为请求添加监听事件的回调函数。var querystring = require(&apos;querystring&apos;);var postData = &apos;&apos;;request.addListener(&apos;data&apos;, function (postDataChunk) &#123; postData += postDataChunk;&#125;);request.addListener(&apos;end&apos;, function () &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&quot;You&apos;ve sent the text: &quot; + querystring.parse(postData).text); response.end();&#125;); http状态码 http的基本用法： 处理get请求处理post请求处理异步操作request对象 发出请求 get()post() server() 算了，下面写 http.STATUS_CODES是一个对象，属性名都是状态码，属性值则是该状态码的简短解释。12require(&apos;http&apos;).STATUS_CODES[&apos;301&apos;]// &quot;Moved Permanently&quot; 模块属性模块属性（1）HTTP请求的属性 &gt; headers：HTTP请求的头信息。 &gt; url：请求的路径。 模块方法（1）http模块的方法 &gt; createServer(callback)：创造服务器实例。（2）服务器实例的方法 &gt; listen(port)：启动服务器监听指定端口。123456789101112131415listen方法用于启动服务器，它可以接受多种参数。var server = new http.Server();// 端口server.listen(8000);// 端口，主机server.listen(8000, &apos;localhost&apos;);// 对象server.listen(&#123; port: 8000, host: &apos;localhost&apos;,&#125;) （3）HTTP回应的方法 &gt; setHeader(key, value)：指定HTTP头信息。 &gt; write(str)：指定HTTP回应的内容。 &gt; end()：发送HTTP回应。 http服务器中：req.end()必须被调用，即使没有在请求体内写入任何数据，也必须调用。因为这表示已经完成HTTP请求。 发送过程的任何错误（DNS错误、TCP错误、HTTP解析错误），都会在request对象上触发error事件。 不想写了： 参考：链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[1月18日 http协议]]></title>
    <url>%2F2019%2F01%2F18%2Fhttp%2F</url>
    <content type="text"><![CDATA[http协议浏览器F12 network给出信息与http报文不太一样，虽说能找到一样请求地址之类的东西，但是……………………有点get不到点上脑子痛 无语 http请求特点：无状态。这次的请求与上一次的请求没有联系。一般cookie和session强行联系，即是http携带COokie或session的数据。 http报文由三部分组成:开始行（请求行）、首部行和实体主体三个部分之间要换行，首部行与实体隔开一个空行开始行（请求行）： 方法 url 版本 （之间有空格）首部行： 字段：值 主体； 例子1234567891011GET /wxisme HTTP/1.1 Host: www.cnblogs.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; zh-CN; rv:1.8.1) Gecko/20061010 Firefox/2.0 Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5 Accept-Language: en-us,zh-cn;q=0.7,zh;q=0.3 Accept-Encoding: gzip,deflate Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Proxy-Connection: keep-alive Cookie: ASP.NET_SessionId=ey5drq45lsomio55hoydzc45Cache-Control: max-age=0 响应报文（格式和请求报文一样）：开始行：版本 状态码 短语首部行：字段：值 实体主体； 12345678910HTTP/1.1 200 OKDate: Tue, 12 Jul 2016 21:36:12 GMTContent-Length: 563Content-Type: text/html&lt;html&gt; &lt;body&gt; Hello http! &lt;/body&gt;&lt;/html&gt; 复制粘贴：四、HTTP请求方法 请求方法是客户端用来告知服务器其动作意图的方法。就像下达命令一样。在HTTP1.1版本中支持GET、POST等近10种方法。需要注意的是方法名区分大小写，需要用大写字母。下面详细说明。 1.GET：获取资源 GET方法用来请求访问已被URI识别的资源。也就是指定了服务器处理请求之后响应的内容。 2.POST：传输实体主体 POST方法用来传输实体主体。POST与GET的区别之一就是目的不同，二者之间的区别会在文章的最后详细说明。虽然GET方法也可以传输，但是一般不用，因为GET的目的是获取，POST的目的是传输。 3.PUT：传输文件 PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。 4.HEAD：获得报文首部 HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。用于确认URI的有效性及资源更新时间等。 5.DELETE：删除文件 DELETE方法用来删除文件，是与PUT相反的方法。DELETE是要求返回URL指定的资源。 6.OPTIONS：询问支持的方法 因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法例如DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。 7.TRACE：追踪路径 TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。这个方法并不常用。 8.CONNECT：要求用隧道协议连接代理 CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL/TLS协议对通信内容加密后传输。 get与post请求：get携带参数会携带在url？或者&amp;符号后面，容易被获取信息，并且url长度有限制，所以get请求方式会有大小限制；post请求会把参数加密； session与cookie &gt;Coolie保存在客户端 &gt;session保存在服务器 &gt;session基于Cookie之上操作。 &gt;session给了Cookie一条钥匙，让服务器辨认。 首部行&amp;以上参考：https://www.cnblogs.com/wxisme/p/6212797.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[一篇糟糕的md文件写成html]]></title>
    <url>%2F2019%2F01%2F17%2Fyou%2F</url>
    <content type="text"><![CDATA[糟糕的标题3打两个空格表示换行请务必记得标签后记得空一空格一切都是两个空格，这是错的但会变色（手动狗头）有序列表以第一个数字为准标记符号记得要空一行，不然 这 是 表 格 真 的 无 语 不 知 数 据 怎 么 获 取 傻逼 引用好用吗好用啊我叫区块引用呵呵 引用包涵体超级引用 你好 世界 无序列表*、+、—都可以创建 有序，与上面隔开 我是第一 我是第二 我是第三 我是第四 # 华丽的分割线table就有两条 分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 4399是什么网站4399是什么网站参数式用法跟链接canshu的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的图片可以像连接一样参数式放进任何地方参数类似于html的title，需要双引号注释什么都会显示出来的代码框，装代码的，不会被使用12345这是注释多行的代码框&lt;p&gt;&lt;/p&gt; 1 2 1 2 转义是反斜杠 _倾斜_加粗 head head head center left right center left right center left right]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F17%2FNew%20Document%2F</url>
    <content type="text"><![CDATA[title: wuliao你好啊啊啊]]></content>
  </entry>
  <entry>
    <title><![CDATA[你好啊]]></title>
    <url>%2F2019%2F01%2F17%2F%E4%BD%A0%E5%A5%BD%E5%95%8A%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
